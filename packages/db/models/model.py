import datetime
import logging
import os
from typing import Any, Dict, List, Optional, ClassVar
from .base import ModelMeta, Field
from weaviate.classes.config import Property, Configure, VectorDistances
from ..managers import CollectionManager, ObjectManager
from ..core.registry import get_weaviate_client
from ..core.providers import ProviderFactory

logger = logging.getLogger(__name__)


class Model(metaclass=ModelMeta):
    """Base model class"""

    _fields: ClassVar[Dict[str, Field]]
    _meta: ClassVar[Any]

    # Object ID (automatically generated by Weaviate)
    id: Optional[str] = None

    # Default object manager
    objects: ClassVar[ObjectManager] = None

    def __init__(self, **kwargs):
        # Set object ID (if provided)
        self.id = kwargs.pop('id', None)

        # Initialize field values
        for field_name, field in self._fields.items():
            value = kwargs.get(field_name)
            setattr(self, field_name, value)

        # Set model reference and attribute name for fields
        for field_name, field in self._fields.items():
            field.contribute_to_class(self.__class__, field_name)

    @classmethod
    def _init_manager(cls):
        """Initialize object manager"""
        if cls.objects is None:
            client = get_weaviate_client()
            cls.objects = ObjectManager(cls, client)

    @classmethod
    def create_collection(cls) -> bool:
        """Create collection"""
        cls._init_manager()
        collection_manager = CollectionManager(get_weaviate_client())
        return collection_manager.create_collection(cls)

    @classmethod
    def delete_collection(cls) -> bool:
        """Delete collection"""
        cls._init_manager()
        collection_manager = CollectionManager(get_weaviate_client())
        return collection_manager.delete_collection(cls)

    @classmethod
    def collection_exists(cls) -> bool:
        """Check if collection exists"""
        collection_manager = CollectionManager(get_weaviate_client())
        return collection_manager.collection_exists(cls)

    def save(self) -> 'Model':
        """Save object"""
        self.__class__._init_manager()
        return self.objects.save(self)

    def delete(self) -> bool:
        """Delete object"""
        self.__class__._init_manager()
        return self.objects.delete(self)

    @classmethod
    def get_collection_info(cls) -> Optional[Dict[str, Any]]:
        """Get collection information"""
        collection_manager = CollectionManager(get_weaviate_client())
        return collection_manager.get_collection_info(cls)

    @classmethod
    def get_collection_name(cls) -> str:
        """Get collection name"""
        if hasattr(cls._meta, 'collection_name'):
            return cls._meta.collection_name
        return cls.__name__

    @classmethod
    def get_vectorizer_config(cls):
        """
        Get vectorizer configuration.
        
        Returns vectorizer config based on model Meta or uses default from provider.
        """
        # If model doesn't have vectorizer configured, use default from provider
        if not hasattr(cls._meta, 'vectorizer'):
            try:
                provider = ProviderFactory.from_env()
                default_vectorizer = provider.get_vectorizer_name()
                return cls._get_vectorizer_by_name(default_vectorizer)
            except Exception as e:
                logger.warning(f"Could not get default vectorizer: {e}, using none")
                return Configure.Vectorizer.none()
        
        vectorizer = cls._meta.vectorizer
        # If configuration is a string, use string configuration
        if isinstance(vectorizer, str):
            return cls._get_vectorizer_by_name(vectorizer)
        else:
            return Configure.Vectorizer.none()

    @classmethod
    def _get_vectorizer_by_name(cls, vectorizer_name: str):
        """Get configuration by vectorizer name"""
        if vectorizer_name == "none":
            return Configure.Vectorizer.none()
        elif vectorizer_name == "text2vec-transformers":
            return Configure.Vectorizer.text2vec_transformers()
        elif vectorizer_name == "text2vec-openai":
            return Configure.Vectorizer.text2vec_openai()
        elif vectorizer_name == "text2vec-cohere":
            return Configure.Vectorizer.text2vec_cohere()
        elif vectorizer_name == "text2vec-aws":
            region = os.getenv("AWS_REGION", "us-east-1")
            config = {
                'model': os.getenv("RAG_EMBEDDINGS_MODEL",'amazon.titan-embed-text-v2:0'),
                'region': region,
                'service': "bedrock"
            }
            logger.info(f"Configuring Weaviate text2vec_aws with region: {region}")
            return Configure.Vectorizer.text2vec_aws(**config)
        elif vectorizer_name == "multi2vec-clip":
            return Configure.Vectorizer.multi2vec_clip()
        elif vectorizer_name == "multi2vec-bind":
            return Configure.Vectorizer.multi2vec_bind()
        else:
            return Configure.Vectorizer.none()


    @classmethod
    def get_vector_index_config(cls):
        """Get vector index configuration"""
        if not hasattr(cls._meta, 'vector_index_config'):
            return None

        config = cls._meta.vector_index_config
        distance = getattr(config, 'distance', VectorDistances.COSINE)

        if distance == VectorDistances.COSINE:
            distance_config = VectorDistances.COSINE
        elif distance == VectorDistances.DOT:
            distance_config = VectorDistances.DOT
        elif distance == VectorDistances.L2_SQUARED:
            distance_config = VectorDistances.L2_SQUARED
        elif distance == VectorDistances.HAMMING:
            distance_config = VectorDistances.HAMMING
        elif distance == VectorDistances.MANHATTAN:
            distance_config = VectorDistances.MANHATTAN
        else:
            distance_config = VectorDistances.COSINE

        return Configure.VectorIndex.hnsw(distance_metric=distance_config)

    @classmethod
    def get_generative_config(cls):
        """Get generative configuration"""
        if not hasattr(cls._meta, 'generative_config'):
            return None
        
        config = cls._meta.generative_config
        if not config:
            return None
        
        # Return corresponding generative configuration based on configuration type
        provider = getattr(config, 'provider', None)
        model = getattr(config, 'model', None)
        
        if not provider:
            return None
            
        if provider == "openai":
            return Configure.Generative.openai(
                model=model or "gpt-3.5-turbo",
                temperature=getattr(config, 'temperature', 0.0),
                max_tokens=getattr(config, 'max_tokens', 500)
            )
        elif provider == "cohere":
            return Configure.Generative.cohere(
                model=model or "command",
                temperature=getattr(config, 'temperature', 0.0),
                max_tokens=getattr(config, 'max_tokens', 500)
            )
        elif provider == "azure-openai":
            return Configure.Generative.azure_openai(
                resource_name=getattr(config, 'resource_name', None),
                deployment_id=getattr(config, 'deployment_id', None),
                temperature=getattr(config, 'temperature', 0.0),
                max_tokens=getattr(config, 'max_tokens', 500)
            )
        elif provider == "aws-bedrock":
            logger.warning("AWS Bedrock generative configuration is not directly supported in current Weaviate version")
            return None
        else:
            return None

    @classmethod
    def get_properties(cls) -> List[Property]:
        """Get all property configurations"""
        properties = []
        for field_name, field in cls._fields.items():
            properties.append(field.to_weaviate_property())
        return properties

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to dictionary format for Weaviate data insertion.
        
        Uses field converters to ensure proper format (e.g., RFC3339 for datetime).
        """
        data = {}
        for field_name, field in self._fields.items():
            value = getattr(self, field_name, None)
            if value is not None:
                # Use field converter if available
                if hasattr(field, 'to_weaviate'):
                    value = field.to_weaviate(value)
                elif isinstance(value, datetime.datetime):
                    # Fallback: ensure RFC3339 format with timezone
                    if value.tzinfo is None:
                        from datetime import timezone
                        value = value.replace(tzinfo=timezone.utc)
                    value = value.isoformat()
                data[field_name] = value
        return data

    def __str__(self):
        return f"<{self.__class__.__name__}: {self.to_dict()}>"

    def __repr__(self):
        return self.__str__()
